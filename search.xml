<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue中Watcher的分类]]></title>
    <url>%2F2018%2F05%2F06%2FVue%E7%9A%84Watcher%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[刚刚看了一篇关于介绍Watcher的文章，让我茅塞顿开。在此记录下自己对Watcher的理解。 Watcher分类内部-watchervue组件上的每一条数据绑定指令(例如)和computed属性，通过compile最后都会生成一个对应的 watcher 对象。 user–watcher 在watch属性中，由用户自己定义的，都属于这种类型，即只要监听的属性改变了，都会触发定义好的回调函数 render-watcher每一个组件都会有一个 render-watcher, function () {vm._update(vm._render(), hydrating);}, 当 data/computed中的属性改变的时候，会调用该 render-watcher 来更新组件的视图 三种 watcher 的执行顺序watcher 也有固定的执行顺序，分别是: 内部-watcher -&gt; user-watcher -&gt; render-watcher 优先执行内部watcher是为了保证指令和DOM节点的优先更新，这样当用户自定义的Wathcer的回调函数触发时DOM已经更新完毕。 ps：Vue里面的概念真是太多了，让我们这些初学者情何以堪！心得：多多吸收知识，当杂乱的知识点多了以后，也许一个简单的Tip，就是一次知识的升华！ “^_^”]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿饿了么--学习笔记]]></title>
    <url>%2F2018%2F04%2F11%2F%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88--%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、https://icomoon.io/ 图表字体生成网站 chrome插件 jsonview格式化json数据 eslint配置 rules{ &apos;semi&apos;:[&apos;error&apos;,&apos;always&apos;], //分号配置 &apos;indent&apos;:0 // 缩进配置 } /* eslint-disable no-new */ new实例写法前加上，可以忽视eslint检查 重定向：{path: &#39;*&#39;, redirect: &#39;/goods&#39;} PC端开发，手机端调试，通过草料生成二维码https://cli.im/，手机访问。必须在同个局域网下。 1像素borer: :after伪类，根据DPR缩放伪类 .border-1px{ position: relative; &amp;:after { display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid rgba(7, 17, 27, 0.1); content: &apos;&apos;; } } @media (-webkit-min-device-pixel-ratio: 1.5), (min-device-pixel-ratio: 1.5) { .border-1px:after { -webkit-transform: scaleY(0.7); ransform: scaleY(0.7); } } css消除空白技巧：1、两个span之间不换行，2、设置父元素的font-size:0； // 内容水平居中 .box-container{ display: flex; justify-cintent: center; align-item: center } &lt;link rel=&apos;stylesheet&apos; type=&apos;test/css&apos; href=&apos;&apos; media=&apos;screen and (max-width: 320px)&apos;&gt; &lt;script&gt; let htmlWidth = document.documentElement.clentWidth || document.body.client; let htmlDom = document.getElemnetByTagname(&apos;html&apos;)[0]; htmpDom.style.fontSize = htmlWidth / 10 +&apos;px; &lt;/script&gt; ***less字符串拼接 .bg-img(@url) { background-image: url( &apos;@{url}@2x.png&apos;); } ***注意mixin中的路径，是相对于mixin文件的路径 文字超出部分隐藏css代码： white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 背景模糊：filter:blur(10px); *CSS Sticky footers布局 两中方案： // 1、flex布局 body{min-height:100vh; display:flex; flex-direction:cloum;} main{flex:1;} // 2、CSS解决 main{min-height:100vh; padding-bottom:50px;} footer{height:50px; margin-top:50px} 背景图片模糊CSS：filter: blur(10px);背景模糊 IOS下： backdrop-filter: blur(10px) 垂直居中最好的方法：dispaly:table dispaly:table-cell vertical-align:middel 上下margin会重合 img元素直接用属性width height vue this.$nextTick() 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 div:ref=’targetName’ this.$refs.targetName取得DOM元素 class=”xx-xx-hook” hook仅仅表示将会被JS选择，没有和实际的样式 Vue.set(this.food, ‘count’, 1); 设置监听对象没有的属性，将会响应式更新 * vue2.0组件间事件派发与接收 https://segmentfault.com/a/1190000008018314 通过new Vue对象，专门管理事件，可以非父子组件通信 1、 mian.js eventHub : new Vue() 组件a this.$root.$emit(&apos;eName&apos;,) 组件b this.$root.$on(&apos;eName&apos;, () =&gt; {}); 2、 父子组件通信，使用自定义事件, 子组件通过this.$emit出发事件， 在父组件的子组件元素中，通过@自定义事件名 接受事件 子组件a @click=&apos;addCart&apos; methods: {addCart(event){ this.$emit(&apos;add&apos;, event.target) } } 父组件b &lt;a @add=&apos;addFood&apos;&gt;&lt;/a&gt; methods: { addFood(){ ... } } 3、 使用Vuex el.getBoundingClentRect(); 获得元素距离视口的坐标 * vue 使用JS钩子函数实现过渡效果 beforeDrop(el) { // 从后往前判断，新运动小球是PUSH let count = this.balls.length; while (count--) { let ball = this.balls[count]; if (ball.show) { // 获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置 let rect = ball.el.getBoundingClientRect(); // 小球初始 left:32 bottom:22 let x = rect.left - 32; let y = -(window.innerHeight - rect.top - 22); el.style.display = &apos;&apos;; el.style.webkitTransform = `translate3d(0,${y}px,0)`; el.style.transform = `translate3d(0,${y}px,0)`; let inner = el.getElementsByClassName(&apos;inner-hook&apos;)[0]; inner.style.webkitTransform = `translate3d(${x}px,0,0)`; inner.style.transform = `translate3d(${x}px,0,0)`; } } }, dropping(el, done) { // 手动触发浏览器重绘 /* eslint-disable no-unused-vars */ let rf = el.offsetHeight; //触发重绘html this.$nextTick(() =&gt; { // 重置偏移位置，即左下角 el.style.webkitTransform = &apos;translate3d(0,0,0)&apos;; el.style.transform = &apos;translate3d(0,0,0)&apos;; let inner = el.getElementsByClassName(&apos;inner-hook&apos;)[0]; inner.style.webkitTransform = &apos;translate3d(0,0,0)&apos;; inner.style.transform = &apos;translate3d(0,0,0)&apos;; // 等待过渡效果执行完毕， 触发动画完成事件afterDrop, 缺失将无法实现小球消失 el.addEventListener(&apos;transitionend&apos;, done); }); }, afterDrop(el) { console.log(&apos;---&apos;); let ball = this.drops.shift(); if (ball) { ball.show = false; el.style.display = &apos;none&apos;; } } *** CSS高度自适应图片技巧（图片加载时，在view中预留位置） .img-wrapper{ position: raletive; width:100; hieght:0; padding-top:100% //技巧，当没有设置高度时，padding值相对与宽度进行计算 } img{ position: absolute; top: 0; left: 0; width: 100%; hieght: 100%; } &lt;a href=&apos;javascript:;&apos;&gt;&lt;/a&gt; 阻止链接的默认行为，防止页面调转 ** $httmp.get(‘./package.json’,{}).then() 可以直接获得package.json的内容，即读取本地json的数据 vue-resourse使用技巧： 拦截器Vue.http.interscptors.push( function(request,next){....}); vue实例下面有个http方法,resourse插件做的封装 http:{ root: &apos;全局地址&apos; } axios 失败的请求通过catch捕获 全局拦截器 axios.interscptors.request.use(function(config){ console.log(&apos;request init...&apos;) return config; }) axios.interscptors.response.use(function(response){ console.log(&apos;response init...&apos;) return response; }) *** AMD、CMD、CommonJS和ES6差异AMD、CMD、CommonJS 是模块化开发的标准和方案 1、AMD(异步模块定义)是RequireJS在推广过程中对模块化定义的规范化产出， 依赖前置 2、CMD(同步模块定义)是SeaJS(淘宝团队)在推广过程中对模块化定义的规范化产出， 用即返回 3、CommonJS规范–module.exports node端推荐使用 4、ES6特性 export/import vue组件中的data是一个函数，通过 return {…}。 目的：组件的数据不应该时贡献的，通过函数返回，可以保证每次引用组件时的data数据对象不是一个。 通过import 可以在组件的script标签内直接导入样式 。 import ‘../style/myStyle.less’ webpack 代理设置： conig/index.js 中，设置 dev:{ proxyTable: { &apos;/goods/*&apos;: { target: &apos;targetUrl:port&apos; } } } 通过代理，可以解决跨域问题 匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window var obj = { func: function() {}, say: function () { // 此时的this就是obj对象 setTimeout(function () { console.log(this) this.func() }.bind(this)); } } obj.say(); // obj 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this ** webpack深入与实战 在页面中想使用自定义的插件： 定义一个 新的类，使用 let Toast = Vue.extend(ToastComponent)进行继承,]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>v前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD、CMD、CommonJS和ES6]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端模块化对前端的模块化进行简单介绍，主要介绍CommonJS模块 和 ES6模块的区别 1、ES6模块ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 1.1 CommonJs模块运行时加载(对象)，ES6模块编译时输出接口 引用阮一峰老师的例子来进行说明： CommonJS的输出缓存机制，使得模块被加载时，会被缓存起来,将整个模块当作一个对象输出。12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。并且，由于缓存机制，重复加载同一模块，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 1.2 CommonJs 模块输出的是一个值的复制，ES6模块编译时输出接口（动态只读引用）CommonJs 模块：对于基本数据类型，属于复制。即会被模块缓存。同时，在另一个模块可以对该模块输出的变量重新赋值，而不会影响其他模块。对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。ES6 模块：ES6 模块的运行机制与 CommonJS不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。 1.3 对于循环引用的处理CommonJS 模块：其重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。例如：12345678910111213141516171819202122// a.jsconsole.log('a start');var b = require('./b.js');console.log('a doing');console.log(b);exports.a = 'a模块的变量';// b.jsconsole.log('b start');var a = require('./b');console.log('b doing')console.log(a);exports.b = 'b模块的变量';// 要理解CommonJS模块是同步执行// 当执行 node a.js时，输出为：// a start// b start// b doing// &#123;&#125;// a doing// &#123;b: 'b模块的变量'&#125; ES6 模块：ES6 模块是动态引用，如果使用import从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。上面例子的ES6改写：1234567891011121314151617181920$ node –experimental-modules a.mjs // a.js console.log('a start'); import &#123;b&#125; from ./b.mjs'; console.log('a doing'); console.log(b); exports.a = 'a模块的变量'; // b.js console.log('b start'); import &#123;a&#125; from ./a.mjs'; console.log('b doing') console.log(a); exports.b = 'b模块的变量'; // 输出 // b start // b ding // ReferenceError: a is not defined 分析：执行a.mjs以后，引擎发现它加载了b.mjs，因此会优先执行b.mjs，然后再执行a.mjs。接着，执行b.mjs的时候，已知它从a.mjs输入了foo接口，这时不会去执行a.mjs，而是认为这个接口已经存在了，继续往下执行。执行到第三行console.log(foo)的时候，才发现这个接口根本没定义，因此报错。 解决方法：123456789101112131415// a.js// exports.a = 'a模块的变量'; 改为export function a () &#123;console.log('a模块的函数')&#125;// b.js// exports.b = 'b模块的变量';export function b () &#123;console.log('b模块的函数')&#125;// 输出// b start// b ding// [Function: a]// a start// b doing// [Funcion: b] 分析：function a(){…}具有提升作用。因此，在import之前，已经存在函数a。 下面简单介绍前端的其它模块化规范。 2、CommonJS规范1、核心思想： 把一个文件当做一个模块，通过require方法同步加载模块。 2、应用场景 Node.js的服务端编程加载的模块主要存在于服务器磁盘，所以加载速度较快，对node这种单线程，影响较小。因此，CommonJS同步加载模块方案主要应用于node服务端。 3、不适用于浏览器环境 浏览器加载方式与服务端完全不同。如果浏览器请求服务器资源时，会由于某个请求加载的时间过长导致浏览器阻塞，不会往下执行，所以就会出现网页打开缓慢的现象。并且，浏览器端是以插入&lt;script&gt;标签的形式来加载资源（ajax方式不行，有跨域问题），没办法让代码同步执行，使用commonJS同步写法会直接报错。 4、示例 12345678910// 1.jsmodule.export = function() &#123; say: function() &#123; alert("你好"); &#125; &#125;// main.jsvar a = require('./a.js');a.say(); 浏览器环境下必须采用异步模式。所以就有了ES6模块、 AMD，CMD 解决方案。 3、AMD规范AMD(异步模块定义)是RequireJS在推广过程中对模块化定义的规范化产出。 1、核心思想： 异步加载所需的模块，然后在回调函数中执行主逻辑。 可以并行加载多个模块，等所有模块都加载并且解释执行完成后，才会执行接下来的代码， 2、吐槽点 “提前执行”：所有依赖模块会被预先下载，并且提前执行（不管该模块的调用时机）。“提前执行”的性能消耗是不容忽视。 3、懒加载 AMD保留了commonjs中的require、exprots、module这三个功能。因此，为了解决“提前执行”的性能消耗，依赖的模块不写在dependencies数组中， 4、示例 123456789101112131415161718192021222324252627282930313233343536// a.jsdefine(function()&#123; return &#123; say: function()&#123; console.log('hello, a.js'); &#125; &#125;&#125;);// b.jsdefine(function()&#123; return &#123; say: function()&#123; console.log('hello, a.js'); &#125; &#125;&#125;);// main.jsrequire(['a', 'b'], function(a, b)&#123; a.say(); $('#b').click(function()&#123; b.say(); &#125;);&#125;)// AMD懒加载方式// main.jsrequire(['a'], function(a)&#123; a.say(); $('#b').click(function()&#123; require(['b'], function(b)&#123; b.say(); &#125;); &#125;);&#125;) 这种懒加载减轻了初始化操作。但是，在需要执行b.say()时，需要实时下载代码然后在回调中才能执行，用户的操作会有明显的延迟卡顿。 4、CMD规范CMD(同步模块定义)是SeaJS(淘宝团队)在推广过程中对模块化定义的规范化产。 1、示例 1234567891011121314151617181920212223242526272829// a.jsdefine(function(require, exports, module)&#123; return &#123; say: function()&#123; console.log('hello, a.js'); &#125; &#125;&#125;);// b.jsdefine(function(require, exports, module)&#123; return &#123; say: function()&#123; console.log('hello, b.js'); &#125; &#125;&#125;);// main.jsdefine(function(require, exports, module)&#123; var a = require('a'); a.say(); $('#b').click(function()&#123; var a = require('b'); b.say(); &#125;); &#125;);&#125;) a.js和b.js都会预先下载，但是，b.js不会预先执行（即用即返回）。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
